1) 선택정렬 :  n개의 원소를 가진 배열이 있을때 첫번째 원소부터 n번째 원소까지 비교하여 가장 작은 값을 찾아 앞으로 계속 보내는 알고리즘

```c++
#include <stdio.h>

int main() {
	int i, j, min, temp, index = -1;
	int arr[10] = { 4,2,6,9,0,3,1,7,8,5};
	for (i = 0; i < 10; i++) {
		min = 100000;
		for (j = i; j < 10; j++) {
			if (min > arr[j]) {
				min = arr[j];
				index = j;
			}
		}
		temp = arr[i];
		arr[i] = min;
		arr[index] = temp;
		printf("%d ", arr[i]);
	}
	return 0;
}
```



- 배열의 인덱스가 0부터 9까지, 1부터 9까지, 2부터 9까지 .... 총 10+9+8+...+1 이므로 n(n+1)/2번을 실행하게 된다. 빅오표기법으로 나타내면 O(n^2)가 된다.





2) 버블정렬 :  n개의 원소를 가진 배열이 있을때 첫번째 원소부터 n번째 원소까지 인접한 두 원소를 비교하여 더 큰 값을 뒤의 인덱스로 넣어 반복적으로 뒤로 보내는 알고리즘

```c++
#include <stdio.h>

int main() {
	int i, j, temp;
	int arr[10] = { 4,2,6,9,0,3,1,7,8,5 };
	for (i = 0; i < 10; i++) {
		for (j = 0; j < 9 - i; j++) { // 0부터 9,8,7,6...0 인덱스 순서로 값을 결정(큰값부터)
			if (arr[j] > arr[j + 1]) {
				temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
	for (i = 0; i < 10; i++) {
		printf("%d ", arr[i]);
	}
	return 0;
}
```



- 배열의 인덱스가 0부터 9까지, 0부터 8까지, 0부터 7까지 .... 총 10+9+8+...+1 이므로 n(n+1)/2번을 실행하게 된다. 빅오표기법으로 나타내면 O(n^2)가 된다. 하지만 앞서 본 선택정렬과 같은 O(n^2)이지만 시간이 오래걸리는데 이유는 swap과정에서 선택정렬은 min의 값만으로 swap을 하지만 버블정렬은 두개의 원소를 비교해 무조건 앞의 원소가 크면 swap하기 때문에 swap과정이 훨씬 많다. 그래서 시간이 더 오래 걸린다. 





3)  삽입정렬 :  n개의 원소를 가진 배열이 있을때 첫번째 원소부터 정렬이 되어있다고 가정하고 1개씩 인덱스를 늘리면서 배열을 정렬하며 각 숫자들을 적절한 위치에 삽입하는 알고리즘



```c++
#include <stdio.h>

int main() {
	int i, j, temp;
	int arr[10] = { 4,2,6,9,0,3,1,7,8,5 };
	for (i = 0; i < 9; i++) {
		j = i;
		while (j >= 0 && arr[j] > arr[j + 1]) {
			temp = arr[j];
			arr[j] = arr[j + 1];
			arr[j + 1] = temp;
			j--;
		}
	}
	for (i = 0; i < 10; i++) {
		printf("%d ", arr[i]);
	}
	return 0;
}
```



- 배열을 첫번째부터 정렬되어있다고 가정을 하여서 1개의 원소를 가진 배열, 2개의 원소를 가진 배열을 비교하여 1+2+3+...+10이므로 n(n+1)/2번을 실행하게 된다. 빅오표기법으로 나타내면 O(n^2)가 된다.  하지만 만약 정렬이 2,3,4,5,6,1 이런식으로 되어있다면 while 문안의 swap을 5번만 실행하게 된다.  (O(n)으로 나타낼 수 있다. )따라서 앞선 두 알고리즘의 정렬보다 시간이 적게 걸려 효율적이라고 생각할 수 있다.