## 블록체인 프로그래밍 3,4,5주차 정리



#### 네트워크

분산 P2P로 실행되지만 개방성에 따라 구분

public: 인터넷과 같이 누구나 참여가능, 메인네트워크의 Homestead(1)

private: 특정 개인이 개설해서 참여하는 권한을 개인이 허락한 참여자만 허용

consortium: 참여가 허용되는 기업을 정해서 네트워크를 구성



#### 네트워크 버전 및 ID

메인네트워크: 거래가 모두 기록이 되고 누구에게나 공유되는 환경, Ether가 유통 (1번)

geth --syncmode light

테스트네트워크: 메인의 복사본으로, 어플리케이션을 테스트하는 네트워크 (3번)

geth --ropsten

사설네트워크: 개인이 개설하여 개방이 제한되며 분산원장으로 본래의 목적인 공유를 할 수 없음, Ether을 사용하지만 실제가치가 없음, 동일한 networkID를 가진 노드일때는 Peer로 참여될 수 있음



#### 계정

**주소 address**는 **20 바이트 코드**로 계정 account의 고유번호이다.

주소는 개인키에서 생성된 공개키로부터 생성:

문자열 해싱 --> 개인키 --(ECDSA)--> 공개키 --(Keccak-256 해싱, BASE58Chcek)--> 주소



개인키 : 무작위로 생성, 32바이트 길이로 생성됨 (16진수 64자리)

개인키->공개키: ECC에 따라 EDCSA알고리즘으로 생성됨, python bitcoin 라이브러리에서 privtopub함수 이용(64바이트)

공개키-> 주소: keccak-256 hashing해서 32바이트 생성하고, 앞의 12바이트를 제거, 뒤 20바이트를 주소로 사용



속성

balance: 잔고를 갖고있는데, 거래의 기록에 잔고가 저장됨

nonce: 거래건수, 트랜잭션이 발생한 건수

storage Root: 계정이 저장된 해시값



#### 해싱

해시의 특징

1. 원본을 되살릴 수 없다.
2. 입력이 동일하면 항상 동일한 고유값을 생성해 낸다.
3. 하지만 원본의 작은 변화에도 해시값은 완전히 다른 고유값이 생성된다.



이더리움에서 해시값의 활용:

1. 공개키를 해싱해서 그 해시값으로 주소를 생성할 때
2. 무결정검증, 거래가 원본임을 확인할 때



#### 디지털서명

송신측: 메시지로부터 해시를 생성한다-> 해시에 개인키를 적용해서 디지털서명을 생성한다

수신측: 송신자가 해놓은 디지털서명을 공개키로 푼다



#### Wallet

우리가 일상생활에서 사용하는 현금, 신용카드등을 가지고있는 지갑, private key와 계정을 갖고있는 데이터베이스



#### 메시지

계정간의 data와 value

call: 로컬 블록체인에서의 호출이라 블록체인에 전송되거나 기록되지는 않음 sendTransaction: 블록체인에 전송되고 기록, 사인을 해야하고 gas가 필요함, 반환값을 알려면 event를 발생시켜서 로그에 적어주고, 나중에 그 로그를 확인해야 함



#### 트랜잭션의 처리단계

노드들은 거래를 받으면 :

- 거래의 **디지털서명**을 인증하여 원본이 맞는지, 소유주의 서명이 맞는지?
- 전송자가 **gas를 지불할 잔고**를 가지고 있는지
- gas가 **gas limit**을 초과하지 않는지 기본적인 검증을 하고 거래를 다시 네트워크에 전파한다.

그래서 다른 노드들은 거래를 블록으로 만들어가고 만들면 모든 네트워크 참여자에게 공지를 하며 블록이체인을 연결, 블록해시를 다음블록에 참조시키면서 연결

거래생성(거래에 디지털 서명을 하고 직렬화)-> 거래전송(p2p네트워크로전송)-> 블록생성(일정시간동안 거래를 묶어서 블록이 될 때까지 pending해놓음, 블록 후보들은 네트워크로 전파되어 우선순위가 정해짐)->블록인증(PoW로 hash puzzle을 풀어서 nonce를 정함) ->새로운블록전파(새로운블럭이라고 공지되면 다른 마이너들은 이 블록 해시값이 올바른지 검사하고 받아들임) 그래서 마이닝이 종료됨



#### 블록체인

**블록헤더** + **블록바디**

블록헤더

1) 프로토콜 버전

2) 이전 블록 해시값

3) 난이도

4) 블록이 생성된 시간

5) nonce

6) 머클 트리의 해시값



블록체인: 블록의 체인이고 거래를 묶어 이진트리 merkle tree로 구성(hash로 이름붙여진 가지노드 leaf node로 구성된 트리)

블록내에서 머클 해시 값을 통해서 트랜잭션의 무결성을 검증할 수 있고, 그에대한 블록해시값을 통해서 헤더값에 대한 무결성을 검증할 수 있음

어느 한 블록에 변조가 발생하면, merkle tree로 root까지 전달되어 블록체인 전체가 변조됨

confirmation: 블록해시값을 연결고리로 블록을 연결하여 블록체인이 생성



#### 마이닝

거래를 인증하는 과정으로 hash puzzle을 풀고 그 보상으로 새로운 코인을 생성

target hash를 찾아내는 계산을 하고 맞추는 경우 인증되고 블록체인에 추가

-> 일정한 양의 계산에 따라 거래가 인증되고 블록체인에 추가 될 수 있음(PoW)

마이닝을 할 경우 적체되어있는 거래가 있는지 먼저 확인하는 것이 필요



#### Gas

트랜잭션을 처리하기 위해서는 비용이 발생, 왜냐하면 노드들의 컴퓨팅 자원이 투입되기 때문에 이에 대한 비용임

거래비용=소모되는 gas*gas price 단가

gas price단가: 사용자가 정할수 있음

gas limit: 거래의 처리에 필요한 최대 사용한도



